# Using Partial Utility Type With Repository Methods

In NestJS (or any application using TypeORM or similar ORMs), methods called on a repository often involve creating, updating, or querying database records based on entities. The `Partial<T>` utility type is a key feature that allows flexibility when passing arguments to these repository methods, especially when the data is incomplete or optional. The `Partial` utility type solves several problems related to the dynamic nature of data creation and modification.

#### What is `Partial<T>`?

`Partial<T>` is a TypeScript utility type that takes a type `T` (usually an entity type like `User`) and makes all of its properties **optional**. This allows you to pass only the necessary or available fields when interacting with the repository, without requiring a complete entity object.

#### Why Use `Partial<T>` for Repository Methods?

There are several reasons to use `Partial<T>` when passing arguments to repository methods in TypeORM:

1. **Handling Incomplete Data**:
   In many cases, the data available when interacting with a repository is incomplete. For example, when creating a new entity, not all fields may be provided. Similarly, during updates, only a subset of fields might be modified. Using `Partial<T>` allows repository methods to accept incomplete objects, representing only the properties that are available.

2. **Database-Generated Fields**:
   Fields like primary keys (`id`), timestamps (`createdAt`, `updatedAt`), or other auto-generated values (e.g., UUIDs) are often handled by the database. These fields are not provided by the client or service logic when creating or updating entities. The `Partial<T>` type lets you exclude these fields when interacting with the repository.

3. **Flexibility for Updates**:
   When updating records, you often don’t want to update every field in an entity. Using `Partial<T>` allows the update method to specify only the fields that need to be modified, while leaving other fields untouched.

4. **Clarity and Simplicity**:
   The `Partial<T>` type simplifies method signatures in your services and repositories by making it clear that the argument passed to a method may not be a fully populated object. This allows developers to focus on just the necessary fields required for the operation.

#### Example 1: Creating a New Entity

Let’s say you have an entity called `User`, with fields like `id` and `createdAt` that are auto-generated by the database:

```typescript
@Entity()
export class User {
  @PrimaryGeneratedColumn()
  id: number;

  @Column()
  name: string;

  @Column()
  email: string;

  @Column({ default: () => "CURRENT_TIMESTAMP" })
  createdAt: Date;
}
```

When creating a new user, the client may only provide the `name` and `email`. The `id` and `createdAt` fields will be handled by the database. If we type the argument as `User` instead of `Partial<User>`, it would expect all fields to be provided, even though some fields should be omitted or generated automatically.

**Without `Partial<T>`**:

```typescript
create(user: User) {
  const newUser = this.userRepository.create(user);
  return this.userRepository.save(newUser);
}
```

This would require providing unnecessary fields like `id` and `createdAt`, even though they are generated by the database. To solve this, we use `Partial<User>`.

**With `Partial<T>`**:

```typescript
create(user: Partial<User>) {
  const newUser = this.userRepository.create(user);  // Only 'name' and 'email' are required
  return this.userRepository.save(newUser);
}
```

Now, we can pass just the fields we care about (`name` and `email`), while TypeORM handles the rest.

**Example**:

```typescript
this.userService.create({ name: "John Doe", email: "john@example.com" });
```

In this case, only `name` and `email` are passed, while `id` and `createdAt` are generated automatically by the database.

#### Example 2: Updating an Entity

Updating an entity is another common scenario where `Partial<T>` is highly beneficial. When updating a user, we may only want to modify certain fields, such as the `email` or `name`. It is inefficient and unnecessary to pass the entire `User` object, especially when only a few fields need to be updated.

**Without `Partial<T>`**:

```typescript
async updateUser(id: number, updatedData: User): Promise<User> {
  const user = await this.userRepository.findOneBy({ id });
  return this.userRepository.save({ ...user, ...updatedData });
}
```

This method requires you to pass a complete `User` object, even if you only want to update a single field, like `email`. Using `Partial<User>`, you can pass just the fields you need to update.

**With `Partial<T>`**:

```typescript
async updateUser(id: number, updatedData: Partial<User>): Promise<User> {
  const user = await this.userRepository.findOneBy({ id });
  return this.userRepository.save({ ...user, ...updatedData });
}
```

Now, the `updatedData` can be just the fields you want to modify.

**Example**:

```typescript
this.userService.updateUser(1, { email: "newemail@example.com" });
```

In this case, only the `email` field is updated, while other fields such as `name`, `id`, and `createdAt` remain unchanged.

#### Example 3: Searching for an Entity

Another useful scenario is using `Partial<T>` when searching for entities. For example, if you want to find a user based on partial criteria (e.g., search by name or email), `Partial<T>` allows you to pass an object containing only the relevant fields.

**Without `Partial<T>`**:

```typescript
findByCriteria(criteria: User): Promise<User[]> {
  return this.userRepository.find({ where: criteria });
}
```

In this case, you would need to pass a complete `User` object, even though you might only want to search by `name` or `email`.

**With `Partial<T>`**:

```typescript
findByCriteria(criteria: Partial<User>): Promise<User[]> {
  return this.userRepository.find({ where: criteria });
}
```

Now, you can search with only the necessary fields.

**Example**:

```typescript
this.userService.findByCriteria({ email: "john@example.com" });
```

In this case, you only pass the `email` field to search for users with that email.

#### Benefits of Using `Partial<T>`

1. **Flexibility**: You can pass only the relevant fields when interacting with the repository, whether creating, updating, or searching for entities.
2. **Efficiency**: You avoid the need to provide or manage fields that are auto-generated by the database (such as `id` or `createdAt`).
3. **Improved Readability**: It makes method signatures clearer and emphasizes that only part of the entity data is required for the operation.
4. **Error Prevention**: Using `Partial<T>` prevents the client or developer from mistakenly supplying unnecessary or inappropriate data.

#### Conclusion

The `Partial<T>` utility type is a powerful tool when working with repositories in NestJS. It allows for flexibility in passing data by enabling partial data to be provided for creating, updating, or querying entities. By using `Partial<T>`, you ensure that repository methods can handle incomplete data, manage auto-generated fields appropriately, and remain focused on only the necessary fields for each operation. This approach leads to more efficient, maintainable, and readable code.
